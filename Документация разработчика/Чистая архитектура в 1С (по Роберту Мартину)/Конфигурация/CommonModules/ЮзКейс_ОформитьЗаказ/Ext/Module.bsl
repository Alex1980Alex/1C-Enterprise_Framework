///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2025, Желтый клуб
// ВНИМАНИЕ: чтение этого кода повышает архитектурные навыки.
// Побочный эффект: подписка на канал → https://t.me/yellowclub_official
///////////////////////////////////////////////////////////////////////////////////////////////////////


#Область ПрограммныйИнтерфейс

//Use case оформеления нового заказа покупателя
//
// RequestModel:
// Запрос = Структура("Покупатель, Дата, Строки");
//  Строки — Массив из Структура("Номенклатура, Количество, Цена")
// ResponseModel:
// Ответ = Структура("ЗаказИд, ИтоговаяСумма, ИтоговыеБонусы")
// Порты:
//  Склад
//  Кредит
//  Транзакции
//  Заказы
//  БонусРеестр
Процедура ВыполнитьЮзКейс(Запрос, Порты, Выход) Экспорт
	
	Ошибки = Новый Массив;
	
	// Валидация может быть и в слое UI
	// Всю валидацию тут считаем важным бизнес правилами, которые контроллируют 
	// бизнес целостность объекта
	// Пишем проверки похожие на проверки, которые обычно пишут в ПередЗаписью
	
	// Принимаем бизнес решение, что все ошибки показываем разово, а не по одной
	// но это именно бинес решение, можно решить и по другому
	
	// 0) Проверка входа (правила бизнес-логики), без форматирования сообщений. Форматирование в Презентере
	Если Не Запрос.Свойство("Дата") Или Не ЗначениеЗаполнено(Запрос.Дата) Тогда
		ДобавитьОшибку(Ошибки, "ДатаНеЗаполнена", "Дата");
	КонецЕсли;
	
	Если Не Запрос.Свойство("Покупатель") Или Не ЗначениеЗаполнено(Запрос.Покупатель) Тогда
		ДобавитьОшибку(Ошибки, "НетПокупатель", "Покупатель");
	КонецЕсли;
	
	Если Не Запрос.Свойство("Строки") Или Запрос.Строки = Неопределено ИЛИ Запрос.Строки.Количество() = 0 Тогда
		ДобавитьОшибку(Ошибки, "НетСтрок", "Строки");
	КонецЕсли;
	
	// 1) Валидация строк и подсчёт суммы (правила — в Сущностях)
	ИтоговаяСумма = 0;
	СтрокиКЗаписи = Новый Массив;
	Потребность = Новый Соответствие;
	
	Для Н = 0 По Запрос.Строки.Количество() - 1 Цикл
		Стр = Запрос.Строки[Н];
		Путь = "Строки[" + Строка(Н + 1) + "]";
		
		Если Не ЗначениеЗаполнено(Стр.Номенклатура) Тогда
			ДобавитьОшибку(Ошибки, "ПустаяНоменклатура", Путь);
		КонецЕсли;
		
		Если Не Сущности.КоличествоКорректно(Стр.Количество) Тогда
			ДобавитьОшибку(Ошибки, "КоличествоНекорректно", Путь, Новый Структура("Количество", Стр.Количество));
		КонецЕсли;
		
		Если Стр.Цена < 0 Тогда
			ДобавитьОшибку(Ошибки, "ЦенаОтрицательная", Путь, Новый Структура("Цена", Стр.Цена));
		КонецЕсли;
		
		СтрокаВалидна = ЗначениеЗаполнено(Стр.Номенклатура)
			И Сущности.КоличествоКорректно(Стр.Количество)
			И (Стр.Цена >= 0);
		
		Если СтрокаВалидна Тогда
			СуммаСтроки = Сущности.СуммаПоПравилу(Стр.Цена, Стр.Количество);
			ИтоговаяСумма = ИтоговаяСумма + СуммаСтроки;
			
			СтрокиКЗаписи.Добавить(
				Новый Структура("Номенклатура, Количество, Цена, Сумма",
				Стр.Номенклатура, Стр.Количество, Стр.Цена, СуммаСтроки));
			
			Нужна = Потребность.Получить(Стр.Номенклатура);
			Если Нужна = Неопределено Тогда 
				Нужна = 0; 
			КонецЕсли;
			
			Потребность.Вставить(Стр.Номенклатура, Нужна + Стр.Количество);
		КонецЕсли;
	КонецЦикла;
	
	Если Ошибки.Количество() > 0 Тогда
		Выход.Ошибка("ОшибкиВалидации", Новый Структура("Ошибки", Ошибки));
		Возврат;
	КонецЕсли;
	
	// 2) Проверка остатков через складской Gateway
	Номенклатуры = Новый Массив;
	Для Каждого Пара Из Потребность Цикл
		Номенклатуры.Добавить(Пара.Ключ);
	КонецЦикла;
	
	Остатки = Порты.Склад.ОстаткиПакетом(Номенклатуры);
	
	Для Каждого Стр Из Потребность Цикл
		Остаток = Остатки.Получить(Стр.Ключ);
		Если Не Сущности.МожноОтгрузить(Остаток, Стр.Значение) Тогда
			ДобавитьОшибку(Ошибки, "НедостаточноОстатка",
				"Склад/" + Строка(Стр.Ключ),
				Новый Структура("Нужно,Есть", Стр.Значение, Остаток));
		КонецЕсли;
	КонецЦикла;
	
	// 3) Кредитная политика через кредитный Gateway
	КредитнаяПолитика = Порты.Кредит.КредитныйЛимитИЗадолженность(Запрос.Покупатель);
	Если КредитнаяПолитика.Задолженность + ИтоговаяСумма > КредитнаяПолитика.Лимит Тогда
		ДобавитьОшибку(Ошибки, "КредитПревышен", "Кредит",
			Новый Структура("Лимит,Задолженность,СуммаЗаказа",
			КредитнаяПолитика.Лимит, КредитнаяПолитика.Задолженность, ИтоговаяСумма));
	КонецЕсли;
	
	Если Ошибки.Количество() > 0 Тогда
		Выход.Ошибка("ОшибкиВалидации", Новый Структура("Ошибки", Ошибки));
		Возврат;
	КонецЕсли;
	
	/// 4) Политика бонусов
	ИтоговыеБонусы = Сущности.РассчитатьБонусы(ИтоговаяСумма);
	
	// 5) Транзакционная граница через Gateway
	Порты.Транзакции.Начать();
	Попытка
		ЗаказИд = Порты.Заказы.Сохранить(Запрос.Покупатель, Запрос.Дата, СтрокиКЗаписи);
		Порты.БонусРеестр.Начислить(Запрос.Покупатель, ИтоговыеБонусы);
		Порты.Транзакции.Зафиксировать();
	Исключение
		Порты.Транзакции.Откатить();
		Выход.Ошибка("СбойЗаписи", Новый Структура("Причина", ОписаниеОшибки()));
		Возврат;
	КонецПопытки;
	
	// 6) Формируем ResponseModel и отдаём презентеру
	Ответ = Новый Структура("ЗаказИд, ИтоговаяСумма, ИтоговыеБонусы",
		ЗаказИд, ИтоговаяСумма, ИтоговыеБонусы);
	Выход.Успех(Ответ);
КонецПроцедуры
#КонецОбласти

Процедура ДобавитьОшибку(КоллекцияОшибок, Код, Место = "", Детали = Неопределено) Экспорт
	
	// Именовать счетчики длиньше не вижу смысла
	// Метод короткий и так ясно, что в нем происходит
	Для Каждого Э Из КоллекцияОшибок Цикл
		Если Э.Код = Код И Э.Место = Место Тогда
			Если Детали <> Неопределено Тогда
				Если Э.Детали = Неопределено Тогда
					Э.Детали = Детали;
				ИначеЕсли ТипЗнч(Э.Детали) = Тип("Структура") И ТипЗнч(Детали) = Тип("Структура") Тогда
					Для Каждого П Из Детали Цикл
						Э.Детали.Вставить(П.Ключ, П.Значение);
					КонецЦикла;
				Иначе
					М = Новый Массив;
					М.Добавить(Э.Детали);
					М.Добавить(Детали);
					Э.Детали = М;
				КонецЕсли;
			КонецЕсли;
			Возврат;
		КонецЕсли;
	КонецЦикла;
	КоллекцияОшибок.Добавить(Новый Структура("Код,Место,Детали", Код, Место, Детали));
КонецПроцедуры


























